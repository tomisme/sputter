From 9a1ad46c3f381d599957c1f522fe0a31f19f3239 Mon Sep 17 00:00:00 2001
From: Adrian Medina <adrian.medina@mail.yu.edu>
Date: Thu, 19 Mar 2015 21:36:01 -0400
Subject: [PATCH] CLJS-1153: Typed Array backed PersistentVector based on
 clojure.core/Vec

---
 src/clj/cljs/core.clj   |  56 ++++-
 src/clj/cljs/util.clj   |   2 +-
 src/cljs/cljs/core.cljs | 561 +++++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 613 insertions(+), 6 deletions(-)

diff --git a/src/clj/cljs/core.clj b/src/clj/cljs/core.clj
index 214c4cf..0adc7b9 100644
--- a/src/clj/cljs/core.clj
+++ b/src/clj/cljs/core.clj
@@ -34,7 +34,9 @@
 
                             cond-> cond->> as-> some-> some->>
 
-                            if-some when-some test ns-interns var vswap!])
+                            if-some when-some test ns-interns var vswap!
+                            
+                            vector-of])
   (:require clojure.walk
             clojure.set
             cljs.compiler
@@ -1972,3 +1974,55 @@
 ;; INTERNAL - do not use, only for Node.js
 (defmacro load-file* [f]
   `(. js/goog (~'nodeGlobalRequire ~f)))
+
+(def ^:private typed-arrays
+  {:byte 'js/Int8Array
+   :ubyte 'js/Uint8Array
+   :short 'js/Int16Array
+   :ushort 'js/Uint16Array
+   :int 'js/Int32Array
+   :uint 'js/Uint32Array
+   :float 'js/Float32Array
+   :double 'js/Float64Array})
+
+(def ^:private empty-vecs
+  {:byte '(.-EMPTY_BYTE cljs.core/Vec)
+   :ubyte '(.-EMPTY_UBYTE cljs.core/Vec)
+   :short '(.-EMPTY_SHORT cljs.core/Vec)
+   :ushort '(.-EMPTY_USHORT cljs.core/Vec)
+   :int '(.-EMPTY_INT cljs.core/Vec)
+   :uint '(.-EMPTY_UINT cljs.core/Vec)
+   :float '(.-EMPTY_FLOAT cljs.core/Vec)
+   :double '(.-EMPTY_DOUBLE cljs.core/Vec)})
+
+(defmacro mk-am
+  [t]
+  `(reify
+     ~'Object
+     (~'array [_# size#] (new ~(typed-arrays t) size#))
+     (~'aclone [_# arr#] (new ~(typed-arrays t) arr#))))
+
+(def ^:private array-managers
+  {:byte '(.-BYTE cljs.core/Vec)
+   :ubyte '(.-UBYTE cljs.core/Vec)
+   :short '(.-SHORT cljs.core/Vec)
+   :ushort '(.-USHORT cljs.core/Vec)
+   :int '(.-INT cljs.core/Vec)
+   :uint '(.-UINT cljs.core/Vec)
+   :float '(.-FLOAT cljs.core/Vec)
+   :double '(.-DOUBLE cljs.core/Vec)})
+
+(defmacro vector-of
+  ([t] (empty-vecs t))
+  ([t & elements]
+   (let [cnt (count elements)
+         am (if (core/keyword? t)
+              (array-managers t)
+              `(-lookup cljs.core/array-managers ~t))]
+     (if (core/< cnt 32)
+       `(new cljs.core/Vec ~am nil ~cnt 5 (.-EMPTY-NODE cljs.core/Vec)
+             (new ~(typed-arrays t) (array ~@elements)) nil)
+       (vary-meta
+        `(.fromArray cljs.core/Vec ~am
+                     (new ~(typed-arrays t) (array ~@elements)) true)
+        assoc :tag 'cljs.core/Vec)))))
diff --git a/src/clj/cljs/util.clj b/src/clj/cljs/util.clj
index cb32e2b..f9c927c 100644
--- a/src/clj/cljs/util.clj
+++ b/src/clj/cljs/util.clj
@@ -15,7 +15,7 @@
            [java.net URL]))
 
 ;; next line is auto-generated by the build-script - Do not edit!
-(def ^:dynamic *clojurescript-version*)
+(def ^:dynamic *clojurescript-version* {:major 0, :minor 0, :qualifier 3133})
 
 (defn ^String clojurescript-version
   "Returns clojurescript version as a printable string."
diff --git a/src/cljs/cljs/core.cljs b/src/cljs/cljs/core.cljs
index aa049b9..4d75228 100644
--- a/src/cljs/cljs/core.cljs
+++ b/src/cljs/cljs/core.cljs
@@ -13,7 +13,7 @@
   (:import goog.string.StringBuffer))
 
 ;; next line is auto-generated by the build-script - Do not edit!
-(def *clojurescript-version*)
+(def *clojurescript-version* "0.0-3133")
 
 (def *unchecked-if* false)
 
@@ -285,15 +285,23 @@
   [array]
   (cljs.core/alength array))
 
-(declare reduce)
+(declare reduce Vec array-managers -count -lookup)
 
 (defn ^array into-array
   "Returns an array with components set to the values in aseq. Optional type
   argument accepted for compatibility with Clojure."
   ([aseq]
-     (into-array nil aseq))
+   (into-array nil aseq))
   ([type aseq]
-     (reduce (fn [a x] (.push a x) a) (array) aseq)))
+   (if (and (keyword? type) (instance? Vec aseq))
+     (let [cnt (-count aseq)
+           arr (.array (-lookup array-managers type) cnt)]
+       (loop [idx 0]
+         (when (< idx cnt)
+           (.set arr (.uncheckedArrayFor aseq idx) idx)
+           (recur (+ idx 32))))
+       arr)
+     (reduce (fn [a x] (.push a x) a) (array) aseq))))
 
 (defn js-invoke
   "Invoke JavaScript object method via string. Needed when the
@@ -9580,3 +9588,548 @@ Maps become Objects. Arbitrary keys are encoded to by key->js."
     (if f
       (do (f) :ok)
       :no-test)))
+
+(declare TransientVec)
+
+(deftype Vec [am meta cnt shift root tail ^:mutable __hash]
+  Object
+  (toString [coll]
+    (pr-str* coll))
+  (equiv [this other]
+    (-equiv this other))
+  (tailoff [coll] (- cnt (alength tail)))
+  (uncheckedArrayFor [coll i]
+    (if (>= i (.tailoff coll))
+      tail
+      (loop [node root level shift]
+        (if (zero? level)
+          (.-arr node)
+          (recur (aget (.-arr node) (bit-and (bit-shift-right i level) 0x1f)) 
+                 (- level 5))))))
+  (arrayFor [coll i]
+    (if (and (<= 0 i) (< i cnt))
+      (.uncheckedArrayFor coll i)
+      (throw (js/Error. "IndexOutOfBoundsException"))))
+  (pushTail [coll level parent tailnode]
+    (let [subidx (bit-and (bit-shift-right (dec cnt) level) 0x1f)
+          ret (VectorNode. (.-edit parent) (aclone (.-arr parent)))
+          node-to-insert (if (= level 5)
+                           tailnode
+                           (let [child (aget (.-arr parent) subidx)]
+                             (if child
+                               (.pushTail coll (- level 5) child tailnode)
+                               (.newPath coll (.-edit root) (- level 5)
+                                         tailnode))))]
+      (aset (.-arr ret) subidx node-to-insert)
+      ret))
+  (popTail [coll level node]
+    (let [subidx (bit-and (bit-shift-right (- cnt 2) level) 0x1f)]
+      (cond
+        (> level 5) 
+        (let [new-child (.popTail coll (- level 5) (aget (.-arr node) subidx))]
+          (if (and (nil? new-child) (zero? subidx))
+            nil
+            (let [arr (aclone (.-arr node))]
+              (aset arr subidx new-child)
+              (VectorNode. (.-edit root) arr))))
+        (zero? subidx) nil
+        :else (let [arr (aclone (.-arr node))]
+                (aset arr subidx nil)
+                (VectorNode. (.-edit root) arr)))))
+  (newPath [coll edit level node]
+    (if (zero? level)
+      node
+      (let [ret (VectorNode. edit (make-array 32))]
+        (aset (.-arr ret) 0 (.newPath coll edit (- level 5) node))
+        ret)))
+  (doAssoc [coll level node i val]
+    (if (zero? level)
+      (let [arr (.aclone am (.-arr node))]
+        (aset arr (bit-and i 0x1f) val)
+        (VectorNode. (.-edit node) arr))
+      (let [arr (aclone (.-arr node))
+            subidx (bit-and (bit-shift-right i level) 0x1f)]
+        (aset arr subidx
+              (.doAssoc coll (- level 5) (aget arr subidx) i val))
+        (VectorNode. (.-edit node) arr))))
+
+  IPrintWithWriter
+  (-pr-writer [coll writer opts]
+    (pr-sequential-writer writer pr-writer "[" " " "]" opts coll))
+
+  ICloneable
+  (-clone [_] (Vec. am meta cnt shift root tail __hash))
+
+  IWithMeta
+  (-with-meta [coll meta] (Vec. am meta cnt shift root tail __hash))
+
+  IMeta
+  (-meta [coll] meta)
+
+  IStack
+  (-peek [coll]
+    (when (pos? cnt)
+      (-nth coll (dec cnt))))
+  (-pop [coll]
+    (cond
+      (zero? cnt) (throw (js/Error. "Can't pop empty vector"))
+      (== 1 cnt) (Vec. am meta 0 5 (.-EMPTY-NODE Vec) (.array am 0)
+                       empty-ordered-hash)
+      (< 1 (- cnt (.tailoff coll)))
+      (Vec. am meta (dec cnt) shift root (.subarray tail 0 -1) nil)
+      :else (let [new-tail (.arrayFor coll (- cnt 2))
+                  nr (.popTail coll shift root)
+                  new-root (if (nil? nr) (.-EMPTY-NODE Vec) nr)
+                  cnt-1 (dec cnt)]
+              (if (and (< 5 shift) (nil? (aget (.-arr new-root) 1)))
+                (Vec. am meta cnt-1 (- shift 5) (aget (.-arr new-root) 0)
+                                   new-tail nil)
+                (Vec. am meta cnt-1 shift new-root new-tail nil)))))
+
+  ICollection
+  (-conj [coll o]
+    (if (< (- cnt (.tailoff coll)) 32)
+      (let [len (alength tail)
+            new-tail (.array am (inc len))]
+        (.set new-tail tail)
+        (aset new-tail len o)
+        (Vec. am meta (inc cnt) shift root new-tail nil))
+      (let [tnode (VectorNode. (.-edit root) tail)
+            root-overflow? (> (bit-shift-right-zero-fill cnt 5)
+                              (bit-shift-left 1 shift))
+            new-shift (if root-overflow? (+ shift 5) shift)
+            new-root (if root-overflow?
+                       (let [nr (VectorNode. (.-edit root) (make-array 32))]
+                         (doto (.-arr nr)
+                           (aset 0 root)
+                           (aset 1 (.newPath coll (.-edit root) shift tnode)))
+                         nr)
+                       (.pushTail coll shift root tnode))]
+        (Vec. am meta (inc cnt) new-shift new-root
+              (let [tl (.array am 1)] (aset tl 0 o) tl) nil))))
+
+  IEmptyableCollection
+  (-empty [coll]
+    (new Vec am meta 0 5 (.-EMPTY-NODE Vec) (.array am 0) empty-ordered-hash))
+
+  ISequential
+  IEquiv
+  (-equiv [coll other]
+    (if (instance? Vec other)
+      (if (== cnt (count other))
+        (let [me-iter  (-iterator coll)
+              you-iter (-iterator other)]
+          (loop []
+            (if (.hasNext me-iter)
+              (let [x (.next me-iter)
+                    y (.next you-iter)]
+                (if (= x y)
+                  (recur)
+                  false))
+              true)))
+        false)
+      (equiv-sequential coll other)))
+
+  IHash
+  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))
+
+  ISeqable
+  (-seq [coll]
+    (cond
+      (zero? cnt) nil
+      (<= cnt 32) (IndexedSeq. tail 0)
+      :else (chunked-seq coll (.arrayFor coll 0) 0 0)))
+
+  ICounted
+  (-count [coll] cnt)
+
+  IIndexed
+  (-nth [coll n]
+    (aget (.arrayFor coll n) (bit-and n 0x01f)))
+  (-nth [coll n not-found]
+    (if (and (<= 0 n) (< n cnt))
+      (aget (.uncheckedArrayFor coll n) (bit-and n 0x01f))
+      not-found))
+
+  ILookup
+  (-lookup [coll k] (-lookup coll k nil))
+  (-lookup [coll k not-found]
+    (if (number? k)
+      (-nth coll k not-found)
+      not-found))
+
+  IMapEntry
+  (-key [coll]
+    (-nth coll 0))
+  (-val [coll]
+    (-nth coll 1))
+
+  IAssociative
+  (-assoc [coll k v]
+    (if (number? k)
+      (-assoc-n coll k v)
+      (throw (js/Error. "Vector's key for assoc must be a number."))))
+
+  IVector
+  (-assoc-n [coll n val]
+    (cond
+      (and (<= 0 n) (< n cnt))
+      (if (<= (.tailoff coll) n)
+        (let [new-tail (.aclone am tail)]
+          (aset new-tail (bit-and n 0x01f) val)
+          (Vec. am meta cnt shift root new-tail nil))
+        (Vec. am meta cnt shift (.doAssoc coll shift root n val) tail nil))
+      (== n cnt) (-conj coll val)
+      :else (throw (js/Error. (str "Index " n " out of bounds  [0," cnt "]")))))
+
+  IReduce
+  (-reduce [v f]
+    (ci-reduce v f))
+  (-reduce [v f init]
+    (loop [i 0 init init]
+      (if (< i cnt)
+        (let [arr  (.uncheckedArrayFor v i)
+              len  (alength arr)
+              init (loop [j 0 init init]
+                     (if (< j len)
+                       (let [init (f init (aget arr j))]
+                         (if (reduced? init)
+                           init
+                           (recur (inc j) init)))
+                       init))]
+          (if (reduced? init)
+            @init
+            (recur (+ i len) init)))
+        init)))
+
+  IKVReduce
+  (-kv-reduce [v f init]
+    (loop [i 0 init init]
+      (if (< i cnt)
+        (let [arr  (.uncheckedArrayFor v i)
+              len  (alength arr)
+              init (loop [j 0 init init]
+                     (if (< j len)
+                       (let [init (f init (+ j i) (aget arr j))]
+                         (if (reduced? init)
+                           init
+                           (recur (inc j) init)))
+                       init))]
+          (if (reduced? init)
+            @init
+            (recur (+ i len) init)))
+        init)))
+
+  IFn
+  (-invoke [coll k]
+    (-nth coll k))
+  (-invoke [coll k not-found]
+    (-nth coll k not-found))
+
+  IEditableCollection
+  (-as-transient [coll]
+    (TransientVec. am cnt shift (tv-editable-root root)
+                   (let [ret (.array am 32)] (.set ret tail) ret)))
+
+  IReversible
+  (-rseq [coll]
+    (if (pos? cnt)
+      (RSeq. coll (dec cnt) nil)))
+
+  IIterable
+  (-iterator [this]
+    (ranged-iterator this 0 cnt)))
+
+(deftype TransientVec [am
+                       ^:mutable cnt
+                       ^:mutable shift
+                       ^:mutable root
+                       ^:mutable tail]
+  Object
+  (tailoff [coll]
+    (if (< cnt 32)
+      0
+      (bit-shift-left (bit-shift-right-zero-fill (dec cnt) 5) 5)))
+  (ensureEditable [coll edit node]
+    (if (identical? edit (.-edit node))
+      node
+      (VectorNode. edit (.aclone am (.-arr node)))))
+  (editableTail [coll]
+    (let [ret (.array am 32)]
+      (.set ret tail)
+      ret))
+  (uncheckedArrayFor [coll i]
+    (if (>= i (.tailoff coll))
+      tail
+      (loop [node root level shift]
+        (if (zero? level)
+          (.-arr node)
+          (recur (.ensureEditable coll (.-edit root)
+                                  (aget (.-arr node)
+                                        (bit-and
+                                         (bit-shift-right-zero-fill i level)
+                                         0x1f)))
+                 (- level 5))))))
+  (arrayFor [coll i]
+    (if (and (<= 0 i) (< i cnt))
+      (.uncheckedArrayFor coll i)
+      (throw (js/Error. "IndexOutOfBoundsException"))))
+  (pushTail [coll level parent tailnode]
+    (let [ret (.ensureEditable coll (.-edit root) parent)
+          subidx (bit-and (bit-shift-right-zero-fill (dec (.-cnt coll)) level)
+                          0x01f)]
+      (aset (.-arr ret) subidx
+            (if (== level 5)
+              tailnode
+              (let [child (aget (.-arr ret) subidx)]
+                (if-not (nil? child)
+                  (.pushTail coll (- level 5) child tailnode)
+                  (.newPath coll (.-edit root) (- level 5) tailnode)))))
+      ret)
+    (let [subidx (bit-and (bit-shift-right (dec cnt) level) 0x1f)
+          ret (VectorNode. (.-edit parent) (aclone (.-arr parent)))
+          node-to-insert (if (== level 5)
+                           tailnode
+                           (let [child (aget (.-arr parent) subidx)]
+                             (if child
+                               (.pushTail coll (- level 5) child tailnode)
+                               (.newPath coll (.-edit root) (- level 5)
+                                         tailnode))))]
+      (aset (.-arr ret) subidx node-to-insert)
+      ret))
+  (popTail [coll level node]
+    (let [node (.ensureEditable coll (.-edit root) node)
+          subidx (bit-and (bit-shift-right-zero-fill (- cnt 2) level) 0x01f)]
+      (cond
+        (> level 5) 
+        (let [new-child (.popTail coll (- level 5) (aget (.-arr node) subidx))]
+          (if (and (nil? new-child) (zero? subidx))
+            nil
+            (do
+              (aset (.-arr node) subidx new-child)
+              node)))
+        (zero? subidx) nil
+        :else (do
+                (aset (.-arr node) subidx nil)
+                node))))
+  (newPath [coll edit level node]
+    (if (zero? level)
+      node
+      (let [ret (VectorNode. edit (make-array 32))]
+        (aset (.-arr ret) 0 (.newPath coll edit (- level 5) node))
+        ret)))
+  (doAssoc [coll level node i val]
+    (if (zero? level)
+      (let [arr (.aclone am (.-arr node))]
+        (aset arr (bit-and i 0x1f) val)
+        (VectorNode. (.-edit node) arr))
+      (let [arr (aclone (.-arr node))
+            subidx (bit-and (bit-shift-right i level) 0x1f)]
+        (aset arr subidx
+              (.doAssoc coll (- level 5) (aget arr subidx) i val))
+        (VectorNode. (.-edit node) arr))))
+  
+  ITransientCollection
+  (-conj! [tcoll o]
+    (if ^boolean (.-edit root)
+        (if (< (- cnt (.tailoff tcoll)) 32)
+          (do (aset tail (bit-and cnt 0x01f) o)
+              (set! cnt (inc cnt))
+              tcoll)
+          (let [tail-node (VectorNode. (.-edit root) tail)
+                new-tail  (.array am 32)]
+            (aset new-tail 0 o)
+            (set! tail new-tail)
+            (if (> (bit-shift-right-zero-fill cnt 5)
+                   (bit-shift-left 1 shift))
+              (let [new-root-array (make-array 32)
+                    new-shift      (+ shift 5)]
+                (aset new-root-array 0 root)
+                (aset new-root-array 1 (.newPath tcoll (.-edit root) shift
+                                                 tail-node))
+                (set! root  (VectorNode. (.-edit root) new-root-array))
+                (set! shift new-shift)
+                (set! cnt   (inc cnt))
+                tcoll)
+              (let [new-root (.pushTail tcoll shift root tail-node)]
+                (set! root new-root)
+                (set! cnt (inc cnt))
+                tcoll))))
+        (throw (js/Error. "conj! after persistent!"))))
+
+  (-persistent! [tcoll]
+    (if ^boolean (.-edit root)
+        (do (set! (.-edit root) nil)
+            (let [len (- cnt (.tailoff tcoll))
+                  trimmed-tail (.subarray tail 0 len)]
+              (Vec. am nil cnt shift root trimmed-tail nil)))
+        (throw (js/Error. "persistent! called twice"))))
+
+  ITransientAssociative
+  (-assoc! [tcoll key val]
+    (if (number? key)
+      (-assoc-n! tcoll key val)
+      (throw (js/Error. "TransientVector's key for assoc! must be a number."))))
+
+  ITransientVector
+  (-assoc-n! [tcoll n val]
+    (if ^boolean (.-edit root)
+        (cond
+          (and (<= 0 n) (< n cnt))
+          (if (<= (.tailoff tcoll) n)
+            (do (aset tail (bit-and n 0x01f) val)
+                tcoll)
+            (let [new-root
+                  ((fn go [level node]
+                     (let [node (.ensureEditable tcoll (.-edit root) node)]
+                       (if (zero? level)
+                         (do (aset (.-arr node) (bit-and n 0x01f) val)
+                             node)
+                         (let [subidx (-> (bit-shift-right-zero-fill n level)
+                                          (bit-and 0x01f))]
+                           (aset (.-arr node) subidx
+                                 (go (- level 5) (aget (.-arr node) subidx)))
+                           node))))
+                   shift root)]
+              (set! root new-root)
+              tcoll))
+          (== n cnt) (-conj! tcoll val)
+          :else
+          (throw
+           (js/Error.
+            (str "Index " n " out of bounds for TransientVector of length"
+                 cnt))))
+        (throw (js/Error. "assoc! after persistent!"))))
+
+  (-pop! [tcoll]
+    (if ^boolean (.-edit root)
+        (cond
+          (zero? cnt) (throw (js/Error. "Can't pop empty vector"))
+          (== 1 cnt)                       (do (set! cnt 0) tcoll)
+          (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)
+          :else
+          (let [new-tail (.uncheckedArrayFor tcoll (- cnt 2))
+                new-root (let [nr (.popTail tcoll shift root)]
+                           (if-not (nil? nr)
+                             nr
+                             (VectorNode. (.-edit root) (make-array 32))))]
+            (if (and (< 5 shift) (nil? (aget (.-arr new-root) 1)))
+              (let [new-root (.ensureEditable tcoll (.-edit root)
+                                              (aget (.-arr new-root) 0))]
+                (set! root  new-root)
+                (set! shift (- shift 5))
+                (set! cnt   (dec cnt))
+                (set! tail  new-tail)
+                tcoll)
+              (do (set! root new-root)
+                  (set! cnt  (dec cnt))
+                  (set! tail new-tail)
+                  tcoll))))
+        (throw (js/Error. "pop! after persistent!"))))
+
+  ICounted
+  (-count [coll]
+    (if ^boolean (.-edit root)
+        cnt
+        (throw (js/Error. "count after persistent!"))))
+
+  IIndexed
+  (-nth [coll n]
+    (if ^boolean (.-edit root)
+        (aget (.arrayFor coll n) (bit-and n 0x01f))
+        (throw (js/Error. "nth after persistent!"))))
+
+  (-nth [coll n not-found]
+    (if (and (<= 0 n) (< n cnt))
+      (-nth coll n)
+      not-found))
+
+  ILookup
+  (-lookup [coll k] (-lookup coll k nil))
+
+  (-lookup [coll k not-found]
+    (if (number? k)
+      (-nth coll k not-found)
+      not-found))
+
+  IFn
+  (-invoke [coll k]
+    (-lookup coll k))
+
+  (-invoke [coll k not-found]
+    (-lookup coll k not-found)))
+
+(set! (.-EMPTY-NODE Vec) (VectorNode. nil (make-array 32)))
+
+(def ^:private array-managers
+  {:byte (set! (.-BYTE Vec) (cljs.core/mk-am :byte))
+   :ubyte (set! (.-UBYTE Vec) (cljs.core/mk-am :ubyte))
+   :short (set! (.-SHORT Vec) (cljs.core/mk-am :short))
+   :ushort (set! (.-USHORT Vec) (cljs.core/mk-am :ushort))
+   :int (set! (.-INT Vec) (cljs.core/mk-am :int))
+   :uint (set! (.-UINT Vec) (cljs.core/mk-am :uint))
+   :float (set! (.-FLOAT Vec) (cljs.core/mk-am :float))
+   :double (set! (.-DOUBLE Vec) (cljs.core/mk-am :double))})
+
+(set! (.-fromArray Vec)
+  (fn [am xs ^boolean no-clone]
+    (let [l (alength xs)
+          xs (if no-clone xs (.aclone am xs))]
+      (if (< l 32)
+        (Vec. am nil l 5 (.-EMPTY-NODE Vec) xs nil)
+        (let [node (.subarray xs 0 32)
+              v (Vec. am nil 32 5 (.-EMPTY-NODE Vec) node nil)]
+          (loop [i 32 out (-as-transient v)]
+            (if (< i l)
+              (recur (inc i) (conj! out (aget xs i)))
+              (persistent! out))))))))
+
+(def ^:private empty-vecs
+  {:byte (set! (.-EMPTY_BYTE Vec)
+               (Vec. (:byte array-managers)
+                     nil 0 5 (.-EMPTY_NODE Vec) (js/Int8Array. 0)
+                     empty-ordered-hash))
+   :ubyte (set! (.-EMPTY_UBYTE Vec)
+                (Vec. (:ubyte array-managers)
+                      nil 0 5 (.-EMPTY_NODE Vec) (js/Uint8Array. 0)
+                      empty-ordered-hash))
+   :short (set! (.-EMPTY_SHORT Vec)
+                (Vec. (:short array-managers)
+                      nil 0 5 (.-EMPTY_NODE Vec) (js/Int16Array. 0)
+                      empty-ordered-hash))
+   :ushort (set! (.-EMPTY_USHORT Vec)
+                 (Vec. (:ushort array-managers)
+                       nil 0 5 (.-EMPTY_NODE Vec) (js/Uint16Array. 0)
+                       empty-ordered-hash))
+   :int (set! (.-EMPTY_INT Vec)
+              (Vec. (:int array-managers)
+                    nil 0 5 (.-EMPTY_NODE Vec) (js/Int32Array. 0)
+                    empty-ordered-hash))
+   :uint (set! (.-EMPTY_UINT Vec)
+               (Vec. (:uint array-managers)
+                     nil 0 5 (.-EMPTY_NODE Vec) (js/Uint32Array. 0)
+                     empty-ordered-hash))
+   :float (set! (.-EMPTY_FLOAT Vec)
+                (Vec. (:float array-managers)
+                      nil 0 5 (.-EMPTY_NODE Vec) (js/Float32Array. 0)
+                      empty-ordered-hash))
+   :double (set! (.-EMPTY_DOUBLE Vec)
+                 (Vec. (:double array-managers)
+                       nil 0 5 (.-EMPTY_NODE Vec) (js/Float64Array. 0)
+                       empty-ordered-hash))})
+
+(defn vector-of
+  "Creates a new vector of a single primitive type t, where t is one
+   of :int :uint :float :double :byte :ubyte :short or :ushort. The
+   resulting vector complies with the interface of vectors in general,
+   but stores the values in Typed Arrays internally.
+
+   Optionally takes one or more elements to populate the vector."
+  ([t] (-lookup empty-vecs t))
+  ([t & elements]
+   (if (and (instance? IndexedSeq elements) (zero? (.-i elements)))
+     (.fromArray Vec (array-managers t) (.-arr elements) true)
+     (-persistent!
+      (reduce -conj!
+        (-as-transient (-lookup empty-vecs t))
+        elements)))))
-- 
2.3.3

